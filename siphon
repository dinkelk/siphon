#!/bin/sh

###############################################
# Global definitions:
###############################################

temp_prefix=".siphon."

###############################################
# Parse input:
###############################################

print_usage()
{
  echo "Usage: siphon [-h?nd] username@hostname:/path/to/dir [path/to/local/dir]"
  echo "Options: -t time interval in seconds to wait between copying new files"
  echo "         -d delete remote files after copying"
  echo "         -n disable color output"
  echo "         -h print usage"
}

if [ $# -lt 1 ]
then
  print_usage
  exit 1
fi

# Argument parsing:
# Good example here: 
# http://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
# A POSIX variable
OPTIND=1 # Reset in case getopts has been used previously in the shell.

# Initialize our own variables:
delete_remote="Y"
color="Y"
time_interval="60"

# Parse options:
while getopts "h?ndt:" opt; do
  case "$opt" in
    h|\?)
      print_usage
      exit 0
      ;;
    t)  time_interval=$OPTARG
      ;;
    d)  delete_remote="Y"
      ;;
    n)  color=
      ;;
    *) 
      echo "Invalid option '$opt'"
      print_usage
      exit 1
  esac
done
shift $((OPTIND-1))
[ "$1" = "--" ] && shift

# Parse input:
remote=$@
remote_username=`echo "$remote" | cut -d "@" -f 1`
remainder=`echo "$remote" | cut -d "@" -f 2`
remote_hostname=`echo "$remainder" | cut -d ":" -f 1`
remainder=`echo "$remainder" | cut -d ":" -f 2`
export remote_port=`echo "$remainder" | tr "~" "/" | cut -d "/" -f 1`
if [ -n "$remote_port" ] 
then
  port_length=`echo $remote_port | wc -c`
  remote_dir=`echo $remainder | cut -c $port_length-`
else
  remote_dir=$remainder
fi

local_dir=$2
if [ -z "$local_dir" ] 
then
  local_dir="."
fi

###############################################
# Print functions:
###############################################

# Color output:
RED='\033[31m'
GREEN='\033[32m'
CYAN='\033[36m'
YELLOW='\033[33m'
BOLD='\033[1m'
NC='\033[0m' # No Color

print_()
{
  if [ -n "$color" ]
  then
    format=$1
    echo $format"[`get_time`]$NC $@"$NC
  else
    echo "[`get_time`] $@"
  fi
}
get_time()
{
  date +"%m-%d-%y %H:%M:%S"
}
print_status()
{
  if [ -n "$color" ]
  then
    print_ "" $BOLD"$@"
  else
    print_ "$@"
  fi
}
print_copy()
{
  if [ -n "$color" ]
  then
    filename=$1
    print_ $GREEN "copying  $BOLD$filename"
  else
    print_ "copying  $filename"
  fi
}
print_warning()
{
  if [ -n "$color" ]
  then
    print_ $YELLOW "$@"
  else
    print_ "$@"
  fi
}
print_copy_warning()
{
  if [ -n "$color" ]
  then
    filename=$1
    shift
    print_warning "warning  $BOLD$filename - $@"
  else
    print_warning "warning  $filename - $@"
  fi
}
print_error()
{
  if [ -n "$color" ]
  then
    print_ $RED$BOLD "$@"
  else
    print_ "$@"
  fi
}
print_copy_error()
{
  if [ -n "$color" ]
  then
    filename=$1
    shift
    print_error "error    $BOLD$filename - $@"
  else
    print_error "error    $filename - $@"
  fi
}

###############################################
# Helper functions:
###############################################

run_remote()
{
  if [ -n "$remote_port" ] 
  then
    ssh -p $remote_port $remote_username@$remote_hostname "$@"
  else
    ssh $remote_username@$remote_hostname "$@"
  fi
}

list_remote_files()
{
  run_remote "ls $remote_dir"
}

list_local_files()
{
  ls $local_dir
}

list_new_files()
{
  remote_temp_file=$local_dir/$temp_prefix"remote.temp"
  local_temp_file=$local_dir/$temp_prefix"local.temp"
  list_remote_files > $remote_temp_file
  list_local_files > $local_temp_file
  # Diff the local vs remote file and extract
  diff $local_temp_file $remote_temp_file | awk '/^\>.*$/ { s = ""; for (i = 2; i <= NF; i++) s = s $i " "; print s }'
  rm -f $local_temp_file $remote_temp_file
}

copy_remote_file()
{
  filename=$1
  print_copy $filename
  local_filename="$local_dir/$filename"
  remote_filename="$remote_dir/$filename"
  temp_filename="$local_dir/$temp_prefix$filename"

  if [ -a "$local_filename" ] || [ -d "$local_filename" ]
  then
    print_copy_warning $filename "already exists, not overwriting."
    return 0
  fi
  
  if [ -n "$remote_port" ] 
  then
    scp -r -P $remote_port $remote_username@$remote_hostname:"$remote_filename" $temp_filename > /dev/null
  else
    scp -r $remote_username@$remote_hostname:"$remote_filename" $temp_filename > /dev/null
  fi

  # Atomically copy over the new file from the temp
  mv $temp_filename $filename

  # Remove the remote file
  if [ -n "$delete_remote" ] 
  then
    run_remote "rm -rf $remote_filename"
  fi
}

copy_remote_files()
{
  new_files=`list_new_files`
  if [ "$?" -ne "0" ]
  then
    print_error "No such file or directory '$remote_username@$remote_hostname:$remote_port$remote_dir'"
    exit 1
  fi
  for new_file in $new_files
  do
    copy_remote_file $new_file
  done
}

cleanup()
{
  echo "cleaning up"
  rm -rf "$temp_prefix*"
}

###############################################
# Main:
###############################################
# Register the signal handler
trap "cleanup; exit 0" SIGHUP SIGINT SIGTERM

print_status "Siphoning files from '$remote_username@$remote_hostname:$remote_port$remote_dir' to '$local_dir'"
print_status "Use ctrl+c to exit..."

# Copy remote files forever:
last_time="0"
while [ 1 ]
do
  current_time=`date +%s`
  time_diff=`expr $current_time - $last_time`
  
  # If enough time has elapsed... copy new files:
  if [ "$time_diff" -ge "$time_interval" ]
  then
    copy_remote_files
    if [ "$?" -ne "0" ]
    then
      exit 1
    fi
    last_time=$current_time
  # Not enough time has elapsed... sleep:
  else
    time_to_sleep=`expr $time_interval - $time_diff`
    echo "sleeping $time_to_sleep"
    sleep $time_to_sleep
  fi
done
